<html>
<head>
<title>resonator_C_resonator.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #0033b3;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resonator_C_resonator.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% 
</span><span class="s1">import </span><span class="s2">Modules.SQcircuit_extensions </span><span class="s1">as </span><span class="s2">sq_ext</span>
<span class="s1">import </span><span class="s2">Modules.figures </span><span class="s1">as </span><span class="s2">figs</span>
<span class="s1">import </span><span class="s2">SQcircuit </span><span class="s1">as </span><span class="s2">sq</span>
<span class="s1">import </span><span class="s2">numpy </span><span class="s1">as </span><span class="s2">np</span>
<span class="s1">import </span><span class="s2">matplotlib.pyplot </span><span class="s1">as </span><span class="s2">plt</span>
<span class="s1">import </span><span class="s2">importlib</span>
<span class="s1">import </span><span class="s2">qutip </span><span class="s1">as </span><span class="s2">qt</span>

<span class="s2">plt.rcParams[</span><span class="s3">'text.usetex'</span><span class="s2">] = </span><span class="s1">False</span>
<span class="s2">importlib.reload(sq_ext)</span>
<span class="s2">importlib.reload(sq)</span>
<span class="s2">importlib.reload(figs)</span>
<span class="s2">np.set_printoptions(linewidth=</span><span class="s4">200</span><span class="s2">, formatter={</span><span class="s3">'float'</span><span class="s2">: </span><span class="s3">'{:.5f}'</span><span class="s2">.format})</span>
<span class="s0">#%% 
</span><span class="s2">fF = </span><span class="s4">1e-15</span>
<span class="s2">nH = </span><span class="s4">1e-9</span>
<span class="s2">C_val = </span><span class="s4">2</span>
<span class="s2">L_val = </span><span class="s4">2</span>
<span class="s0">#%% 
</span><span class="s1">def </span><span class="s2">resonator_C_resonator(Cc, C_val=C_val, L_val=L_val):</span>
    <span class="s2">Cc = sq.Capacitor(Cc, </span><span class="s3">'fF'</span><span class="s2">)</span>
    <span class="s2">C = sq.Capacitor(C_val,   </span><span class="s3">'fF'</span><span class="s2">)</span>
    <span class="s2">L = sq.Inductor (L_val,   </span><span class="s3">'nH'</span><span class="s2">)</span>
    <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C],</span>
                <span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">): [L, C],</span>
                <span class="s2">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">): [Cc], }</span>
    <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>

<span class="s1">def </span><span class="s2">resonator_resonator(connected=</span><span class="s1">True</span><span class="s2">):</span>
    <span class="s2">C = sq.Capacitor(C_val, </span><span class="s3">'fF'</span><span class="s2">)</span>
    <span class="s2">L = sq.Inductor (L_val,  </span><span class="s3">'nH'</span><span class="s2">)</span>
    <span class="s1">if </span><span class="s2">connected:</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C, L, C], }</span>
    <span class="s1">else</span><span class="s2">:</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C],</span>
                    <span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">): [L, C], }</span>
    <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>

<span class="s1">def </span><span class="s2">resonator_resonator_eq(connected=</span><span class="s1">True</span><span class="s2">):</span>
    <span class="s1">if </span><span class="s2">connected:</span>
        <span class="s2">C = sq.Capacitor(C_val+C_val, </span><span class="s3">'fF'</span><span class="s2">)</span>
        <span class="s2">L = sq.Inductor ((</span><span class="s4">1</span><span class="s2">/L_val+</span><span class="s4">1</span><span class="s2">/L_val)**-</span><span class="s4">1</span><span class="s2">, </span><span class="s3">'nH'</span><span class="s2">)</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C], }</span>
    <span class="s1">else</span><span class="s2">:</span>
        <span class="s2">C = sq.Capacitor(C_val, </span><span class="s3">'fF'</span><span class="s2">)</span>
        <span class="s2">L = sq.Inductor (L_val,  </span><span class="s3">'nH'</span><span class="s2">)</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C],</span>
                    <span class="s2">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">): [L, C], }</span>
    <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>

<span class="s1">def </span><span class="s2">resonator(Cc):</span>
    <span class="s0"># CC = sq.Capacitor(Cc, 'fF')</span>
    <span class="s0"># C = sq.Capacitor(C_val, 'fF')</span>
    <span class="s0"># L = sq.Inductor(L_val,  'nH')</span>
    <span class="s0"># elements = {(0, 2): [L],</span>
    <span class="s0">#             (0, 1): [C],</span>
    <span class="s0">#             (1, 2): [CC]}</span>
    <span class="s0"># return sq.Circuit(elements)</span>
    
    <span class="s1">if </span><span class="s2">Cc == </span><span class="s4">0</span><span class="s2">:</span>
        <span class="s2">C = sq.Capacitor(C_val, </span><span class="s3">'fF'</span><span class="s2">)</span>
        <span class="s2">L = sq.Inductor(L_val,  </span><span class="s3">'nH'</span><span class="s2">)</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C], }</span>
        <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>
    <span class="s1">else</span><span class="s2">:</span>
        <span class="s2">C = sq.Capacitor(</span><span class="s4">1</span><span class="s2">/(</span><span class="s4">1</span><span class="s2">/C_val+</span><span class="s4">1</span><span class="s2">/Cc), </span><span class="s3">'fF'</span><span class="s2">)</span>
        <span class="s2">L = sq.Inductor (L_val, </span><span class="s3">'nH'</span><span class="s2">)</span>
        <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C], }</span>
    <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>
    
<span class="s1">def </span><span class="s2">shutned_resonator(Cc):</span>
    <span class="s2">Cc = sq.Capacitor(Cc, </span><span class="s3">'fF'</span><span class="s2">)</span>
    <span class="s2">C = sq.Capacitor(C_val,   </span><span class="s3">'fF'</span><span class="s2">)</span>
    <span class="s2">L = sq.Inductor (L_val,   </span><span class="s3">'nH'</span><span class="s2">)</span>
    <span class="s2">elements = {(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">): [L, C, Cc], }</span>
    <span class="s1">return </span><span class="s2">sq.Circuit(elements)</span>
<span class="s0">#%% 
</span><span class="s2">n_eig = </span><span class="s4">8</span>
<span class="s2">trunc_num = </span><span class="s4">60</span>
<span class="s2">Cc = </span><span class="s4">1</span>
<span class="s0">#%% 
</span><span class="s2">coupled_res = resonator_C_resonator(Cc=Cc)</span>
<span class="s2">res = resonator(Cc=Cc)</span>

<span class="s2">uncoupled_res = resonator_C_resonator(Cc=</span><span class="s4">0</span><span class="s2">)</span>
<span class="s2">res_0 = resonator(Cc=</span><span class="s4">0</span><span class="s2">)</span>

<span class="s2">uncoupled_renormalized_res = resonator_C_resonator(Cc=</span><span class="s4">0</span><span class="s2">, C_val=(</span><span class="s4">1</span><span class="s2">/C_val+</span><span class="s4">1</span><span class="s2">/Cc)**-</span><span class="s4">1</span><span class="s2">, L_val=L_val)</span>
<span class="s2">renormalized_res = resonator(Cc=Cc)</span>

<span class="s2">coupled_res.set_trunc_nums([trunc_num, trunc_num])</span>
<span class="s2">uncoupled_res.set_trunc_nums([trunc_num, trunc_num])</span>
<span class="s2">uncoupled_renormalized_res.set_trunc_nums([trunc_num, trunc_num])</span>
<span class="s2">res.set_trunc_nums([trunc_num  ])</span>
<span class="s2">res_0.set_trunc_nums([trunc_num])</span>
<span class="s2">renormalized_res.set_trunc_nums([trunc_num])</span>

<span class="s2">_ = coupled_res.diag(n_eig)</span>
<span class="s2">_ = uncoupled_res.diag(n_eig)</span>
<span class="s2">_ = uncoupled_renormalized_res.diag(n_eig)</span>
<span class="s2">_ = res.diag(n_eig)</span>
<span class="s2">_ = res_0.diag(n_eig)</span>
<span class="s2">_ = renormalized_res.diag(n_eig)</span>
<span class="s0">#%% 
</span><span class="s2">Q_0 = res_0._charge_op_isolated(</span><span class="s4">0</span><span class="s2">)</span>
<span class="s2">Φ_0 = res_0._flux_op_isolated(</span><span class="s4">0</span><span class="s2">)</span>

<span class="s2">Q = res._charge_op_isolated(</span><span class="s4">0</span><span class="s2">)</span>
<span class="s2">Φ = res._flux_op_isolated(</span><span class="s4">0</span><span class="s2">)</span>
<span class="s0">#%% 
# H_res_0 = 1 / 2 * (1/fF)               * Q_0 ** 2  + 1 / 2 * (1/nH) * Φ_0 ** 2</span>
<span class="s0"># H_res   = 1 / 2 * (1/fF) * (1 + 1/Cc)  * Q ** 2    + 1 / 2 * (1/nH) * Φ   ** 2# </span>
<span class="s2">H_res_0 = res_0.hamiltonian()</span>
<span class="s2">H_res   = res.hamiltonian()</span>

<span class="s2">I = qt.identity(H_res.shape[</span><span class="s4">0</span><span class="s2">])</span>

<span class="s2">H_unc_res = qt.tensor(H_res_0, I) + qt.tensor(I, H_res_0)</span>

<span class="s2">H_unc_renorm = qt.tensor(H_res, I) + qt.tensor(I, H_res)</span>

<span class="s2">H_coup_res = qt.tensor(H_res, I) + qt.tensor(I, H_res) -  (</span><span class="s4">0.5 </span><span class="s2">/ (Cc*fF)) * qt.tensor(Q, Q)</span>
<span class="s0">#%% 
</span><span class="s2">E = sq_ext.diag(H_coup_res,n_eig=n_eig, out=</span><span class="s3">'GHz'</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s2">E -= E[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s2">E/</span><span class="s4">2</span>
<span class="s0">#%% 
</span><span class="s2">E/E[</span><span class="s4">1</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s2">E = coupled_res.efreqs - coupled_res.efreqs[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s2">E</span>
<span class="s0">#%% 
</span><span class="s2">E/E[</span><span class="s4">1</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s2">E_0 = sq_ext.diag(H_unc_renorm,n_eig=n_eig, out=</span><span class="s3">'GHz'</span><span class="s2">)[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s2">E_0 - E_0[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s2">uncoupled_renormalized_res.efreqs - uncoupled_renormalized_res.efreqs[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s1">import </span><span class="s2">numpy </span><span class="s1">as </span><span class="s2">np</span>
<span class="s1">from </span><span class="s2">scipy.linalg </span><span class="s1">import </span><span class="s2">eigh</span>

<span class="s0"># Parameters</span>
<span class="s2">hbar = </span><span class="s4">1   </span><span class="s0"># Planck constant (can be set to 1 for simplicity)</span>
<span class="s2">C = (</span><span class="s4">1</span><span class="s2">/C_val+</span><span class="s4">1</span><span class="s2">/Cc)**-</span><span class="s4">1 </span><span class="s2">* fF</span>
<span class="s2">L = L_val * nH</span>
<span class="s2">omega = </span><span class="s4">1</span><span class="s2">/np.sqrt(L*C) </span><span class="s0"># Resonant frequency of the LC circuits</span>
<span class="s2">g = </span><span class="s4">1</span><span class="s2">*np.sqrt(C/L)/(Cc*fF)    </span><span class="s0"># Coupling strength</span>

<span class="s0"># Creation and annihilation operators for a single quantum state</span>
<span class="s1">def </span><span class="s2">create(n):</span>
    <span class="s1">return </span><span class="s2">np.diag(np.sqrt(np.arange(</span><span class="s4">1</span><span class="s2">, n)), -</span><span class="s4">1</span><span class="s2">)</span>

<span class="s1">def </span><span class="s2">annihilate(n):</span>
    <span class="s1">return </span><span class="s2">np.diag(np.sqrt(np.arange(</span><span class="s4">1</span><span class="s2">, n)), </span><span class="s4">1</span><span class="s2">)</span>

<span class="s0"># Size of the matrix (for 2 quanta in each mode)</span>
<span class="s2">n = </span><span class="s4">3  </span><span class="s0"># Number of states for each mode (0, 1, 2)</span>

<span class="s0"># Create operators for each mode</span>
<span class="s2">a1 = np.kron(create(n), np.eye(n))</span>
<span class="s2">a1_dagger = np.kron(annihilate(n), np.eye(n))</span>
<span class="s2">a2 = np.kron(np.eye(n), create(n))</span>
<span class="s2">a2_dagger = np.kron(np.eye(n), annihilate(n))</span>

<span class="s0"># Construct the Hamiltonian</span>
<span class="s2">H = hbar * omega * (np.dot(a1_dagger, a1) + np.dot(a2_dagger, a2)) + hbar * g * (np.dot(a1_dagger, a2) + np.dot(a1, a2_dagger))</span>

<span class="s0"># Find the eigenvalues (energy levels)</span>
<span class="s2">energies = eigh(H, eigvals_only=</span><span class="s1">True</span><span class="s2">)</span>

<span class="s0"># Print the energy levels</span>
<span class="s2">E = energies/ </span><span class="s4">2 </span><span class="s2">/ np.pi</span>
<span class="s2">E -= E[</span><span class="s4">0</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s2">E/E[</span><span class="s4">1</span><span class="s2">]</span>
<span class="s0">#%% 
</span><span class="s2">g/omega</span>
<span class="s0">#%% 
</span></pre>
</body>
</html>